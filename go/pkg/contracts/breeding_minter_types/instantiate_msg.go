// Code generated by schema-generate. DO NOT EDIT.

package breeding_minter_types

import (
	"bytes"
	"encoding/json"
	"errors"
)

// InstantiateMsg
type InstantiateMsg struct {
	BreedCountLimit    int    `json:"breed_count_limit"`
	BreedDuration      int    `json:"breed_duration"`
	BreedPriceAmount   string `json:"breed_price_amount"`
	BreedPriceDenom    string `json:"breed_price_denom"`
	ChildNftBaseUri    string `json:"child_nft_base_uri"`
	ChildNftCi         int    `json:"child_nft_ci"`
	ChildNftMaxSupply  int    `json:"child_nft_max_supply"`
	ChildNftName       string `json:"child_nft_name"`
	ChildNftSymbol     string `json:"child_nft_symbol"`
	ParentContractAddr string `json:"parent_contract_addr"`
}

func (strct *InstantiateMsg) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "BreedCountLimit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "breed_count_limit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"breed_count_limit\": ")
	if tmp, err := json.Marshal(strct.BreedCountLimit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "BreedDuration" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "breed_duration" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"breed_duration\": ")
	if tmp, err := json.Marshal(strct.BreedDuration); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "BreedPriceAmount" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "breed_price_amount" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"breed_price_amount\": ")
	if tmp, err := json.Marshal(strct.BreedPriceAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "BreedPriceDenom" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "breed_price_denom" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"breed_price_denom\": ")
	if tmp, err := json.Marshal(strct.BreedPriceDenom); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ChildNftBaseUri" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "child_nft_base_uri" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"child_nft_base_uri\": ")
	if tmp, err := json.Marshal(strct.ChildNftBaseUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ChildNftCi" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "child_nft_ci" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"child_nft_ci\": ")
	if tmp, err := json.Marshal(strct.ChildNftCi); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ChildNftMaxSupply" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "child_nft_max_supply" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"child_nft_max_supply\": ")
	if tmp, err := json.Marshal(strct.ChildNftMaxSupply); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ChildNftName" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "child_nft_name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"child_nft_name\": ")
	if tmp, err := json.Marshal(strct.ChildNftName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ChildNftSymbol" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "child_nft_symbol" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"child_nft_symbol\": ")
	if tmp, err := json.Marshal(strct.ChildNftSymbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ParentContractAddr" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "parent_contract_addr" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"parent_contract_addr\": ")
	if tmp, err := json.Marshal(strct.ParentContractAddr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstantiateMsg) UnmarshalJSON(b []byte) error {
	breed_count_limitReceived := false
	breed_durationReceived := false
	breed_price_amountReceived := false
	breed_price_denomReceived := false
	child_nft_base_uriReceived := false
	child_nft_ciReceived := false
	child_nft_max_supplyReceived := false
	child_nft_nameReceived := false
	child_nft_symbolReceived := false
	parent_contract_addrReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "breed_count_limit":
			if err := json.Unmarshal([]byte(v), &strct.BreedCountLimit); err != nil {
				return err
			}
			breed_count_limitReceived = true
		case "breed_duration":
			if err := json.Unmarshal([]byte(v), &strct.BreedDuration); err != nil {
				return err
			}
			breed_durationReceived = true
		case "breed_price_amount":
			if err := json.Unmarshal([]byte(v), &strct.BreedPriceAmount); err != nil {
				return err
			}
			breed_price_amountReceived = true
		case "breed_price_denom":
			if err := json.Unmarshal([]byte(v), &strct.BreedPriceDenom); err != nil {
				return err
			}
			breed_price_denomReceived = true
		case "child_nft_base_uri":
			if err := json.Unmarshal([]byte(v), &strct.ChildNftBaseUri); err != nil {
				return err
			}
			child_nft_base_uriReceived = true
		case "child_nft_ci":
			if err := json.Unmarshal([]byte(v), &strct.ChildNftCi); err != nil {
				return err
			}
			child_nft_ciReceived = true
		case "child_nft_max_supply":
			if err := json.Unmarshal([]byte(v), &strct.ChildNftMaxSupply); err != nil {
				return err
			}
			child_nft_max_supplyReceived = true
		case "child_nft_name":
			if err := json.Unmarshal([]byte(v), &strct.ChildNftName); err != nil {
				return err
			}
			child_nft_nameReceived = true
		case "child_nft_symbol":
			if err := json.Unmarshal([]byte(v), &strct.ChildNftSymbol); err != nil {
				return err
			}
			child_nft_symbolReceived = true
		case "parent_contract_addr":
			if err := json.Unmarshal([]byte(v), &strct.ParentContractAddr); err != nil {
				return err
			}
			parent_contract_addrReceived = true
		}
	}
	// check if breed_count_limit (a required property) was received
	if !breed_count_limitReceived {
		return errors.New("\"breed_count_limit\" is required but was not present")
	}
	// check if breed_duration (a required property) was received
	if !breed_durationReceived {
		return errors.New("\"breed_duration\" is required but was not present")
	}
	// check if breed_price_amount (a required property) was received
	if !breed_price_amountReceived {
		return errors.New("\"breed_price_amount\" is required but was not present")
	}
	// check if breed_price_denom (a required property) was received
	if !breed_price_denomReceived {
		return errors.New("\"breed_price_denom\" is required but was not present")
	}
	// check if child_nft_base_uri (a required property) was received
	if !child_nft_base_uriReceived {
		return errors.New("\"child_nft_base_uri\" is required but was not present")
	}
	// check if child_nft_ci (a required property) was received
	if !child_nft_ciReceived {
		return errors.New("\"child_nft_ci\" is required but was not present")
	}
	// check if child_nft_max_supply (a required property) was received
	if !child_nft_max_supplyReceived {
		return errors.New("\"child_nft_max_supply\" is required but was not present")
	}
	// check if child_nft_name (a required property) was received
	if !child_nft_nameReceived {
		return errors.New("\"child_nft_name\" is required but was not present")
	}
	// check if child_nft_symbol (a required property) was received
	if !child_nft_symbolReceived {
		return errors.New("\"child_nft_symbol\" is required but was not present")
	}
	// check if parent_contract_addr (a required property) was received
	if !parent_contract_addrReceived {
		return errors.New("\"parent_contract_addr\" is required but was not present")
	}
	return nil
}
