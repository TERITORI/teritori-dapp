// Code generated by schema-generate. DO NOT EDIT.

package bunker_minter_types

import (
	"bytes"
	"encoding/json"
	"errors"
)

// InstantiateMsg
type InstantiateMsg struct {
	MintMax        interface{} `json:"mint_max,omitempty"`
	NftBaseUri     string      `json:"nft_base_uri"`
	NftCi          int         `json:"nft_ci"`
	NftMaxSupply   string      `json:"nft_max_supply"`
	NftName        string      `json:"nft_name"`
	NftPriceAmount string      `json:"nft_price_amount"`
	NftSymbol      string      `json:"nft_symbol"`
	PriceDenom     string      `json:"price_denom"`

	// The payment address, may be different to or the same as the minter addr question: how do we validate this?
	RoyaltyPaymentAddress interface{} `json:"royalty_payment_address,omitempty"`

	// This is how much the minter takes as a cut when sold royalties are owed on this token if it is Some
	RoyaltyPercentage        interface{} `json:"royalty_percentage,omitempty"`
	SecondaryDuringMint      interface{} `json:"secondary_during_mint,omitempty"`
	WhitelistMintMax         interface{} `json:"whitelist_mint_max,omitempty"`
	WhitelistMintPeriod      int         `json:"whitelist_mint_period"`
	WhitelistMintPriceAmount interface{} `json:"whitelist_mint_price_amount,omitempty"`
}

func (strct *InstantiateMsg) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "mint_max" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mint_max\": ")
	if tmp, err := json.Marshal(strct.MintMax); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftBaseUri" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_base_uri" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_base_uri\": ")
	if tmp, err := json.Marshal(strct.NftBaseUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftCi" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_ci" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_ci\": ")
	if tmp, err := json.Marshal(strct.NftCi); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftMaxSupply" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_max_supply" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_max_supply\": ")
	if tmp, err := json.Marshal(strct.NftMaxSupply); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftName" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_name\": ")
	if tmp, err := json.Marshal(strct.NftName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftPriceAmount" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_price_amount" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_price_amount\": ")
	if tmp, err := json.Marshal(strct.NftPriceAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "NftSymbol" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "nft_symbol" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nft_symbol\": ")
	if tmp, err := json.Marshal(strct.NftSymbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "PriceDenom" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "price_denom" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"price_denom\": ")
	if tmp, err := json.Marshal(strct.PriceDenom); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "royalty_payment_address" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"royalty_payment_address\": ")
	if tmp, err := json.Marshal(strct.RoyaltyPaymentAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "royalty_percentage" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"royalty_percentage\": ")
	if tmp, err := json.Marshal(strct.RoyaltyPercentage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "secondary_during_mint" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"secondary_during_mint\": ")
	if tmp, err := json.Marshal(strct.SecondaryDuringMint); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "whitelist_mint_max" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"whitelist_mint_max\": ")
	if tmp, err := json.Marshal(strct.WhitelistMintMax); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "WhitelistMintPeriod" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "whitelist_mint_period" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"whitelist_mint_period\": ")
	if tmp, err := json.Marshal(strct.WhitelistMintPeriod); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "whitelist_mint_price_amount" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"whitelist_mint_price_amount\": ")
	if tmp, err := json.Marshal(strct.WhitelistMintPriceAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InstantiateMsg) UnmarshalJSON(b []byte) error {
	nft_base_uriReceived := false
	nft_ciReceived := false
	nft_max_supplyReceived := false
	nft_nameReceived := false
	nft_price_amountReceived := false
	nft_symbolReceived := false
	price_denomReceived := false
	whitelist_mint_periodReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "mint_max":
			if err := json.Unmarshal([]byte(v), &strct.MintMax); err != nil {
				return err
			}
		case "nft_base_uri":
			if err := json.Unmarshal([]byte(v), &strct.NftBaseUri); err != nil {
				return err
			}
			nft_base_uriReceived = true
		case "nft_ci":
			if err := json.Unmarshal([]byte(v), &strct.NftCi); err != nil {
				return err
			}
			nft_ciReceived = true
		case "nft_max_supply":
			if err := json.Unmarshal([]byte(v), &strct.NftMaxSupply); err != nil {
				return err
			}
			nft_max_supplyReceived = true
		case "nft_name":
			if err := json.Unmarshal([]byte(v), &strct.NftName); err != nil {
				return err
			}
			nft_nameReceived = true
		case "nft_price_amount":
			if err := json.Unmarshal([]byte(v), &strct.NftPriceAmount); err != nil {
				return err
			}
			nft_price_amountReceived = true
		case "nft_symbol":
			if err := json.Unmarshal([]byte(v), &strct.NftSymbol); err != nil {
				return err
			}
			nft_symbolReceived = true
		case "price_denom":
			if err := json.Unmarshal([]byte(v), &strct.PriceDenom); err != nil {
				return err
			}
			price_denomReceived = true
		case "royalty_payment_address":
			if err := json.Unmarshal([]byte(v), &strct.RoyaltyPaymentAddress); err != nil {
				return err
			}
		case "royalty_percentage":
			if err := json.Unmarshal([]byte(v), &strct.RoyaltyPercentage); err != nil {
				return err
			}
		case "secondary_during_mint":
			if err := json.Unmarshal([]byte(v), &strct.SecondaryDuringMint); err != nil {
				return err
			}
		case "whitelist_mint_max":
			if err := json.Unmarshal([]byte(v), &strct.WhitelistMintMax); err != nil {
				return err
			}
		case "whitelist_mint_period":
			if err := json.Unmarshal([]byte(v), &strct.WhitelistMintPeriod); err != nil {
				return err
			}
			whitelist_mint_periodReceived = true
		case "whitelist_mint_price_amount":
			if err := json.Unmarshal([]byte(v), &strct.WhitelistMintPriceAmount); err != nil {
				return err
			}
		}
	}
	// check if nft_base_uri (a required property) was received
	if !nft_base_uriReceived {
		return errors.New("\"nft_base_uri\" is required but was not present")
	}
	// check if nft_ci (a required property) was received
	if !nft_ciReceived {
		return errors.New("\"nft_ci\" is required but was not present")
	}
	// check if nft_max_supply (a required property) was received
	if !nft_max_supplyReceived {
		return errors.New("\"nft_max_supply\" is required but was not present")
	}
	// check if nft_name (a required property) was received
	if !nft_nameReceived {
		return errors.New("\"nft_name\" is required but was not present")
	}
	// check if nft_price_amount (a required property) was received
	if !nft_price_amountReceived {
		return errors.New("\"nft_price_amount\" is required but was not present")
	}
	// check if nft_symbol (a required property) was received
	if !nft_symbolReceived {
		return errors.New("\"nft_symbol\" is required but was not present")
	}
	// check if price_denom (a required property) was received
	if !price_denomReceived {
		return errors.New("\"price_denom\" is required but was not present")
	}
	// check if whitelist_mint_period (a required property) was received
	if !whitelist_mint_periodReceived {
		return errors.New("\"whitelist_mint_period\" is required but was not present")
	}
	return nil
}
