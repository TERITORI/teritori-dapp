/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, ExecMsg, Uint64, Uint128, Binary, MembershipConfig, Coin, QueryMsg, QueryMsg1, Cw2981QueryMsg, AdminFundsResponse, Expiration, Timestamp, AllNftInfoResponseForMetadata, OwnerOfResponse, Approval, NftInfoResponseForMetadata, Metadata, Trait, TokensResponse, Addr, ChannelResponse, ChannelFundsResponse, ArrayOfUint64, Config, ContractInfoResponse, Cw2981Response, CheckRoyaltiesResponse, RoyaltiesInfoResponse, NumTokensResponse, SubscriptionResponse, Subscription } from "./Cw721Membership.types";
export interface Cw721MembershipReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  channel: ({
    channelId
  }: {
    channelId: Uint64;
  }) => Promise<ChannelResponse>;
  channelsByOwner: ({
    limit,
    ownerAddress,
    startAfter
  }: {
    limit?: number;
    ownerAddress: string;
    startAfter?: Uint64;
  }) => Promise<ArrayOfUint64>;
  adminFunds: () => Promise<AdminFundsResponse>;
  channelFunds: ({
    channelId
  }: {
    channelId: Uint64;
  }) => Promise<ChannelFundsResponse>;
  subscription: ({
    channelId,
    subAddr
  }: {
    channelId: Uint64;
    subAddr: string;
  }) => Promise<SubscriptionResponse>;
  extension: ({
    msg
  }: {
    msg: Cw2981QueryMsg;
  }) => Promise<Cw2981Response>;
  ownerOf: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  contractInfo: () => Promise<ContractInfoResponse>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponseForMetadata>;
  allNftInfo: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<AllNftInfoResponseForMetadata>;
  tokens: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<TokensResponse>;
}
export class Cw721MembershipQueryClient implements Cw721MembershipReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.channel = this.channel.bind(this);
    this.channelsByOwner = this.channelsByOwner.bind(this);
    this.adminFunds = this.adminFunds.bind(this);
    this.channelFunds = this.channelFunds.bind(this);
    this.subscription = this.subscription.bind(this);
    this.extension = this.extension.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.contractInfo = this.contractInfo.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.allNftInfo = this.allNftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  channel = async ({
    channelId
  }: {
    channelId: Uint64;
  }): Promise<ChannelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel: {
        channel_id: channelId
      }
    });
  };
  channelsByOwner = async ({
    limit,
    ownerAddress,
    startAfter
  }: {
    limit?: number;
    ownerAddress: string;
    startAfter?: Uint64;
  }): Promise<ArrayOfUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channels_by_owner: {
        limit,
        owner_address: ownerAddress,
        start_after: startAfter
      }
    });
  };
  adminFunds = async (): Promise<AdminFundsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin_funds: {}
    });
  };
  channelFunds = async ({
    channelId
  }: {
    channelId: Uint64;
  }): Promise<ChannelFundsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel_funds: {
        channel_id: channelId
      }
    });
  };
  subscription = async ({
    channelId,
    subAddr
  }: {
    channelId: Uint64;
    subAddr: string;
  }): Promise<SubscriptionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      subscription: {
        channel_id: channelId,
        sub_addr: subAddr
      }
    });
  };
  extension = async ({
    msg
  }: {
    msg: Cw2981QueryMsg;
  }): Promise<Cw2981Response> => {
    return this.client.queryContractSmart(this.contractAddress, {
      extension: {
        msg
      }
    });
  };
  ownerOf = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponseForMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  allNftInfo = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<AllNftInfoResponseForMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_nft_info: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface Cw721MembershipInterface extends Cw721MembershipReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createChannel: ({
    membershipsConfig,
    tradeRoyaltiesAddr,
    tradeRoyaltiesPer10k
  }: {
    membershipsConfig: MembershipConfig[];
    tradeRoyaltiesAddr?: string;
    tradeRoyaltiesPer10k: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateChannel: ({
    id,
    membershipsConfig,
    tradeRoyaltiesAddr,
    tradeRoyaltiesPer10k
  }: {
    id: Uint64;
    membershipsConfig?: MembershipConfig[];
    tradeRoyaltiesAddr?: string;
    tradeRoyaltiesPer10k?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  subscribe: ({
    channelId,
    membershipKind,
    recipientAddr
  }: {
    channelId: Uint64;
    membershipKind: number;
    recipientAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    adminAddr,
    description,
    imageUri,
    mintRoyalties,
    name,
    symbol
  }: {
    adminAddr?: string;
    description?: string;
    imageUri?: string;
    mintRoyalties?: number;
    name?: string;
    symbol?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateChannelMintPlatformFee: ({
    channelId,
    mintRoyalties
  }: {
    channelId: Uint64;
    mintRoyalties?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawMintPlatformFee: ({
    destinationAddr
  }: {
    destinationAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawMintFunds: ({
    channelId,
    destinationAddr
  }: {
    channelId: Uint64;
    destinationAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferNft: ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendNft: ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class Cw721MembershipClient extends Cw721MembershipQueryClient implements Cw721MembershipInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createChannel = this.createChannel.bind(this);
    this.updateChannel = this.updateChannel.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateChannelMintPlatformFee = this.updateChannelMintPlatformFee.bind(this);
    this.withdrawMintPlatformFee = this.withdrawMintPlatformFee.bind(this);
    this.withdrawMintFunds = this.withdrawMintFunds.bind(this);
    this.transferNft = this.transferNft.bind(this);
    this.sendNft = this.sendNft.bind(this);
    this.burn = this.burn.bind(this);
  }

  createChannel = async ({
    membershipsConfig,
    tradeRoyaltiesAddr,
    tradeRoyaltiesPer10k
  }: {
    membershipsConfig: MembershipConfig[];
    tradeRoyaltiesAddr?: string;
    tradeRoyaltiesPer10k: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_channel: {
        memberships_config: membershipsConfig,
        trade_royalties_addr: tradeRoyaltiesAddr,
        trade_royalties_per10k: tradeRoyaltiesPer10k
      }
    }, fee, memo, _funds);
  };
  updateChannel = async ({
    id,
    membershipsConfig,
    tradeRoyaltiesAddr,
    tradeRoyaltiesPer10k
  }: {
    id: Uint64;
    membershipsConfig?: MembershipConfig[];
    tradeRoyaltiesAddr?: string;
    tradeRoyaltiesPer10k?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_channel: {
        id,
        memberships_config: membershipsConfig,
        trade_royalties_addr: tradeRoyaltiesAddr,
        trade_royalties_per10k: tradeRoyaltiesPer10k
      }
    }, fee, memo, _funds);
  };
  subscribe = async ({
    channelId,
    membershipKind,
    recipientAddr
  }: {
    channelId: Uint64;
    membershipKind: number;
    recipientAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      subscribe: {
        channel_id: channelId,
        membership_kind: membershipKind,
        recipient_addr: recipientAddr
      }
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    adminAddr,
    description,
    imageUri,
    mintRoyalties,
    name,
    symbol
  }: {
    adminAddr?: string;
    description?: string;
    imageUri?: string;
    mintRoyalties?: number;
    name?: string;
    symbol?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        admin_addr: adminAddr,
        description,
        image_uri: imageUri,
        mint_royalties: mintRoyalties,
        name,
        symbol
      }
    }, fee, memo, _funds);
  };
  updateChannelMintPlatformFee = async ({
    channelId,
    mintRoyalties
  }: {
    channelId: Uint64;
    mintRoyalties?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_channel_mint_platform_fee: {
        channel_id: channelId,
        mint_royalties: mintRoyalties
      }
    }, fee, memo, _funds);
  };
  withdrawMintPlatformFee = async ({
    destinationAddr
  }: {
    destinationAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_mint_platform_fee: {
        destination_addr: destinationAddr
      }
    }, fee, memo, _funds);
  };
  withdrawMintFunds = async ({
    channelId,
    destinationAddr
  }: {
    channelId: Uint64;
    destinationAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_mint_funds: {
        channel_id: channelId,
        destination_addr: destinationAddr
      }
    }, fee, memo, _funds);
  };
  transferNft = async ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_nft: {
        recipient,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  sendNft = async ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_nft: {
        contract,
        msg,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}