/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, ExecMsg, Uint64, Uint128, MembershipConfig, Coin, QueryMsg, QueryMsg1, AdminFundsResponse, Expiration, Timestamp, AllNftInfoResponseForMetadata, OwnerOfResponse, Approval, NftInfoResponseForMetadata, Metadata, Trait, TokensResponse, ChannelResponse, ChannelFundsResponse, ContractInfoResponse, NumTokensResponse, SubscriptionResponse, Subscription } from "./Cw721Membership.types";
export interface Cw721MembershipReadOnlyInterface {
  contractAddress: string;
  channel: ({
    channelAddr
  }: {
    channelAddr: string;
  }) => Promise<ChannelResponse>;
  adminFunds: () => Promise<AdminFundsResponse>;
  channelFunds: ({
    channelAddr
  }: {
    channelAddr: string;
  }) => Promise<ChannelFundsResponse>;
  subscription: ({
    channelAddr,
    subAddr
  }: {
    channelAddr: string;
    subAddr: string;
  }) => Promise<SubscriptionResponse>;
  ownerOf: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  contractInfo: () => Promise<ContractInfoResponse>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponseForMetadata>;
  allNftInfo: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<AllNftInfoResponseForMetadata>;
  tokens: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<TokensResponse>;
}
export class Cw721MembershipQueryClient implements Cw721MembershipReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.channel = this.channel.bind(this);
    this.adminFunds = this.adminFunds.bind(this);
    this.channelFunds = this.channelFunds.bind(this);
    this.subscription = this.subscription.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.contractInfo = this.contractInfo.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.allNftInfo = this.allNftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
  }

  channel = async ({
    channelAddr
  }: {
    channelAddr: string;
  }): Promise<ChannelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel: {
        channel_addr: channelAddr
      }
    });
  };
  adminFunds = async (): Promise<AdminFundsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin_funds: {}
    });
  };
  channelFunds = async ({
    channelAddr
  }: {
    channelAddr: string;
  }): Promise<ChannelFundsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel_funds: {
        channel_addr: channelAddr
      }
    });
  };
  subscription = async ({
    channelAddr,
    subAddr
  }: {
    channelAddr: string;
    subAddr: string;
  }): Promise<SubscriptionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      subscription: {
        channel_addr: channelAddr,
        sub_addr: subAddr
      }
    });
  };
  ownerOf = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponseForMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  allNftInfo = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<AllNftInfoResponseForMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_nft_info: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface Cw721MembershipInterface extends Cw721MembershipReadOnlyInterface {
  contractAddress: string;
  sender: string;
  upsertChannel: ({
    membershipsConfig
  }: {
    membershipsConfig: MembershipConfig[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  subscribe: ({
    channelAddr,
    membershipKind,
    recipientAddr
  }: {
    channelAddr: string;
    membershipKind: number;
    recipientAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    adminAddr,
    mintRoyalties
  }: {
    adminAddr?: string;
    mintRoyalties?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateChannelMintPlatformFee: ({
    channelAddr,
    mintRoyalties
  }: {
    channelAddr: string;
    mintRoyalties: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawMintPlatformFee: ({
    destinationAddr
  }: {
    destinationAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawMintFunds: ({
    channelAddr,
    destinationAddr
  }: {
    channelAddr: string;
    destinationAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferNft: ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class Cw721MembershipClient extends Cw721MembershipQueryClient implements Cw721MembershipInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.upsertChannel = this.upsertChannel.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateChannelMintPlatformFee = this.updateChannelMintPlatformFee.bind(this);
    this.withdrawMintPlatformFee = this.withdrawMintPlatformFee.bind(this);
    this.withdrawMintFunds = this.withdrawMintFunds.bind(this);
    this.transferNft = this.transferNft.bind(this);
    this.burn = this.burn.bind(this);
  }

  upsertChannel = async ({
    membershipsConfig
  }: {
    membershipsConfig: MembershipConfig[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upsert_channel: {
        memberships_config: membershipsConfig
      }
    }, fee, memo, _funds);
  };
  subscribe = async ({
    channelAddr,
    membershipKind,
    recipientAddr
  }: {
    channelAddr: string;
    membershipKind: number;
    recipientAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      subscribe: {
        channel_addr: channelAddr,
        membership_kind: membershipKind,
        recipient_addr: recipientAddr
      }
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    adminAddr,
    mintRoyalties
  }: {
    adminAddr?: string;
    mintRoyalties?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        admin_addr: adminAddr,
        mint_royalties: mintRoyalties
      }
    }, fee, memo, _funds);
  };
  updateChannelMintPlatformFee = async ({
    channelAddr,
    mintRoyalties
  }: {
    channelAddr: string;
    mintRoyalties: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_channel_mint_platform_fee: {
        channel_addr: channelAddr,
        mint_royalties: mintRoyalties
      }
    }, fee, memo, _funds);
  };
  withdrawMintPlatformFee = async ({
    destinationAddr
  }: {
    destinationAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_mint_platform_fee: {
        destination_addr: destinationAddr
      }
    }, fee, memo, _funds);
  };
  withdrawMintFunds = async ({
    channelAddr,
    destinationAddr
  }: {
    channelAddr: string;
    destinationAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_mint_funds: {
        channel_addr: channelAddr,
        destination_addr: destinationAddr
      }
    }, fee, memo, _funds);
  };
  transferNft = async ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_nft: {
        recipient,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}