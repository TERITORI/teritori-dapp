/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, ExecMsg, Binary, Addr, Cw721ReceiveMsg, CollectionItems, Redistribution, QueryMsg, QueryMsg1, Timestamp, Uint64, GameState, Game, ArrayOfAddr, Uint32, ArrayOfTupleOfAddrAndString } from "./Arena.types";
export interface ArenaReadOnlyInterface {
  contractAddress: string;
  getGame: ({
    gameId
  }: {
    gameId: number;
  }) => Promise<Game>;
  getPlayerGameId: ({
    playerAddr
  }: {
    playerAddr: string;
  }) => Promise<Uint32>;
  getPlayerItems: ({
    playerAddr
  }: {
    playerAddr: string;
  }) => Promise<ArrayOfTupleOfAddrAndString>;
  getGamePlayers: ({
    gameId
  }: {
    gameId: number;
  }) => Promise<ArrayOfAddr>;
}
export class ArenaQueryClient implements ArenaReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getGame = this.getGame.bind(this);
    this.getPlayerGameId = this.getPlayerGameId.bind(this);
    this.getPlayerItems = this.getPlayerItems.bind(this);
    this.getGamePlayers = this.getGamePlayers.bind(this);
  }

  getGame = async ({
    gameId
  }: {
    gameId: number;
  }): Promise<Game> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_game: {
        game_id: gameId
      }
    });
  };
  getPlayerGameId = async ({
    playerAddr
  }: {
    playerAddr: string;
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_player_game_id: {
        player_addr: playerAddr
      }
    });
  };
  getPlayerItems = async ({
    playerAddr
  }: {
    playerAddr: string;
  }): Promise<ArrayOfTupleOfAddrAndString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_player_items: {
        player_addr: playerAddr
      }
    });
  };
  getGamePlayers = async ({
    gameId
  }: {
    gameId: number;
  }): Promise<ArrayOfAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_game_players: {
        game_id: gameId
      }
    });
  };
}
export interface ArenaInterface extends ArenaReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receiveCw721: ({
    cw721Msg
  }: {
    cw721Msg: Cw721ReceiveMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  retrieveItems: ({
    items
  }: {
    items: CollectionItems[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createGame: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinGame: ({
    gameId
  }: {
    gameId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveGame: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  startGame: ({
    gameId
  }: {
    gameId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  abortGame: ({
    gameId
  }: {
    gameId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  endGame: ({
    gameId,
    redistributions
  }: {
    gameId: number;
    redistributions: Redistribution[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    authoritiesToAdd,
    authoritiesToRemove,
    collectionsToAdd,
    collectionsToRemove,
    newAdmin
  }: {
    authoritiesToAdd: string[];
    authoritiesToRemove: string[];
    collectionsToAdd: string[];
    collectionsToRemove: string[];
    newAdmin?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaClient extends ArenaQueryClient implements ArenaInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receiveCw721 = this.receiveCw721.bind(this);
    this.retrieveItems = this.retrieveItems.bind(this);
    this.createGame = this.createGame.bind(this);
    this.joinGame = this.joinGame.bind(this);
    this.leaveGame = this.leaveGame.bind(this);
    this.startGame = this.startGame.bind(this);
    this.abortGame = this.abortGame.bind(this);
    this.endGame = this.endGame.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
  }

  receiveCw721 = async ({
    cw721Msg
  }: {
    cw721Msg: Cw721ReceiveMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive_cw721: {
        cw721_msg: cw721Msg
      }
    }, fee, memo, _funds);
  };
  retrieveItems = async ({
    items
  }: {
    items: CollectionItems[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      retrieve_items: {
        items
      }
    }, fee, memo, _funds);
  };
  createGame = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_game: {}
    }, fee, memo, _funds);
  };
  joinGame = async ({
    gameId
  }: {
    gameId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_game: {
        game_id: gameId
      }
    }, fee, memo, _funds);
  };
  leaveGame = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_game: {}
    }, fee, memo, _funds);
  };
  startGame = async ({
    gameId
  }: {
    gameId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      start_game: {
        game_id: gameId
      }
    }, fee, memo, _funds);
  };
  abortGame = async ({
    gameId
  }: {
    gameId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      abort_game: {
        game_id: gameId
      }
    }, fee, memo, _funds);
  };
  endGame = async ({
    gameId,
    redistributions
  }: {
    gameId: number;
    redistributions: Redistribution[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      end_game: {
        game_id: gameId,
        redistributions
      }
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    authoritiesToAdd,
    authoritiesToRemove,
    collectionsToAdd,
    collectionsToRemove,
    newAdmin
  }: {
    authoritiesToAdd: string[];
    authoritiesToRemove: string[];
    collectionsToAdd: string[];
    collectionsToRemove: string[];
    newAdmin?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        authorities_to_add: authoritiesToAdd,
        authorities_to_remove: authoritiesToRemove,
        collections_to_add: collectionsToAdd,
        collections_to_remove: collectionsToRemove,
        new_admin: newAdmin
      }
    }, fee, memo, _funds);
  };
}